<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html" />
    <title>How to compile SFMTp</title>
    <style type="text/css">
      BLOCKQUOTE {background-color:#a0ffa0;
                  padding-left: 1em;}
    </style>
  </head>
  <body>
    <h2> How to compile SFMT </h2>

    <p>
      This document explains how to compile SFMTp for users who
      are using UNIX like systems (for example Linux, Free BSD,
      cygwin, osx, etc) on terminal. I can't help those who use IDE
      (Integrated Development Environment,) please see your IDE's help
      to use SIMD feature of your CPU.
    </p>

    <h3>1. First Step: Compile test programs using Makefile.</h3>
    <h4>1-1. Compile standard C test program.</h4>
    <p>
      Check if SFMTp.c and Makefile are in your current directory.
      If not, <strong>cd</strong> to the directory where they exist.
      Then, type
    </p>
      <blockquote>
	<pre>make std</pre>
      </blockquote>
    <p>
      If it causes an error, try to type
    </p>
    <blockquote>
      <pre>cc -o test-std32-M19937 test32.c</pre>
    </blockquote>
    <p>
      or try to type
    </p>
    <blockquote>
      <pre>gcc -o test-std32-M19937 test32.c</pre>
    </blockquote>
    <p>
      If success, then check the test program. Type
    </p>
    <blockquote>
      <pre>./test-std32-M19937</pre>
    </blockquote>
    <p>
      You will see many random numbers displayed on your screen.
      If you want to check these random numbers are correct output,
      redirect output to a file and <strong>diff</strong> it with
      <strong>SFMTp.19937.out.txt</strong>, like this:</p>
    <blockquote>
      <pre>./test-std32-M19937 > foo.txt
diff -w foo.txt SFMTp.19937.out.txt</pre>
    </blockquote>
    <p>
      Silence means they are the same because <strong>diff</strong>
      reports the diffrence of two file.
    </p>
    <p>
      If you want to know the generation speed of SFMTp, type
    </p>
    <blockquote>
      <pre>./test-std32-M19937 -s</pre>
    </blockquote>
    <p>
      It is very slow. To make it fast, compile it
      with <strong>-O3</strong> option. If your compiler is gcc, you
      should specify <strong>-fno-strict-aliasing</strong> option
      with <strong>-O3</strong>. type
    </p>
    <blockquote>
      <pre>gcc -O3 -fno-strict-aliasing -o test-std32-M19937 test32.c
./test-std32-M19937 -s</pre>
    </blockquote>

    <h4>1-2. Compile SSE2 test program.</h4>
    <p>
      If your CPU supports SSE2 and you can use gcc version 3.4 or later,
      you can make test-sse32. To do this, type
    </p>
    <blockquote>
      <pre>make sse2</pre>
    </blockquote>
    <p>or type</p>
    <blockquote>
      <pre>gcc -O3 -msse2 -fno-strict-aliasing -DSSE2=1 -o test-sse32-M19937 test32.c</pre>
    </blockquote>
    <p>If everything works well,</p>
    <blockquote>
      <pre>./test-sse32-M19937 -s</pre>
    </blockquote>
      <p>shows much shorter time than <strong>test-std32-M19937 -s</strong>.</p>

    <h4>1-3. Compile AltiVec test program.</h4>
    <p>
      If you are using Macintosh computer with PowerPC G4 or G5, and
      your gcc version is later 3.3, you can make test-alti32-M19937. To
      do this, type
    </p>
    <blockquote>
      <pre>make alti</pre>
    </blockquote>
    <p>or type</p>
    <blockquote>
      <pre>gcc -O3 -faltivec -fno-strict-aliasing -DALTIVEC=1 -o test-alti32-M19937 test32.c</pre>
    </blockquote>
    <p>If everything works well,</p>
    <blockquote>
      <pre>./test-alti32-M19937 -s</pre>
    </blockquote>
    <p>shows much shorter time than <strong>test-std32-M19937 -s</strong>.</p>

    <h4>1-4. Compile and check output automatically.</h4>
    <p>
      To make test program and check 32-bit and 64-bit output
      automatically for all supported MEXPs of SFMTp, type
    </p>
    <blockquote>
      <pre>make std-check</pre>
    </blockquote>
    <p>
      To check test program optimized for SSE2, type
    </p>
    <blockquote>
      <pre>make sse2-check</pre>
    </blockquote>
    <p>
      To check test program optimized for AltiVec, type
    </p>
    <blockquote>
      <pre>make alti-check</pre>
    </blockquote>
    <p>
      These commands may take some time.
    </p>

    <h3>2. Second Step: Use SFMTp pseudorandom number generator with
    your C program.</h3>
    <h4>2-1. Use sequential call and static link.</h4>
    <p>
      Here is a very simple program <strong>sample1.c</strong> which
      calculates PI using Monte-Carlo method.
    </p>
    <blockquote>
      <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "SFMTp.h"

int main(int argc, char* argv[]) {
    int i, cnt, seed;
    double x, y, pi;
    const int NUM = 10000;

    if (argc &gt;= 2) {
	seed = strtol(argv[1], NULL, 10);
    } else {
	seed = 12345;
    }
    cnt = 0;
    init_gen_rand(seed);
    for (i = 0; i &lt; NUM; i++) {
	x = genrand_res53();
	y = genrand_res53();
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample1.c</strong> with SFMTp.c with the period of 
      2<sup>607</sup>, type</p>
    <blockquote>
      <pre>gcc -DMEXP=607 -o sample1 SFMTp.c sample1.c</pre>
    </blockquote>
    <p>If your CPU supports SSE2 and you want to use optimized SFMTp for
      SSE2, type</p>
    <blockquote>
      <pre>gcc -msse2 -DMEXP=607 -o sample1 SFMTp-sse2.c sample1.c</pre>
    </blockquote>
    <p>If your CPU supports AltiVec and you want to use optimized SFMTp
      for AltiVec, type</p>
    <blockquote>
      <pre>gcc -faltivec -DMEXP=607 -o sample1 SFMTp-alti32.c sample1.c</pre>
    </blockquote>

    <h4>2-2. Use block call and static link.</h4>
    <p>
      Here is <strong>sample2.c</strong> which modifies sample1.c.
      The block call <strong>fill_array64</strong> is much faster than
      sequential call, but it needs an aligned memory. The standard function
      to get an alligned memory is <strong>posix_memalign</strong>, but 
      it isn't usable in every OS.
    </p>
    <blockquote>
      <pre>
#include &lt;stdio.h&gt;
#if !defined(_POSIX_C_SOURCE)
#include &lt;malloc.h&gt;
#endif
#define _XOPEN_SOURCE 600
#include &lt;stdlib.h&gt;
#include "SFMTp.h"

int main(int argc, char* argv[]) {
    int i, j, cnt, seed;
    double x, y, pi;
    const int NUM = 10000;
    const int R_SIZE = 2 * NUM;
    uint64_t *array;

    if (argc &gt;= 2) {
	seed = strtol(argv[1], NULL, 10);
    } else {
	seed = 12345;
    }
#if defined(__APPLE__)
    printf("malloc used\n");
    array = malloc(sizeof(uint64_t) * R_SIZE);
    if (array == NULL) {
	printf("can't allocate memory.\n");
	return 1;
    }
#elif defined(_POSIX_C_SOURCE)
    printf("posix_memalign used\n");
    if (posix_memalign((void **)&amp;array, 16, sizeof(uint64_t) * R_SIZE) != 0) {
	printf("can't allocate memory.\n");
	return 1;
    }
#elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 3))
    printf("memalign used\n");
    array = memalign(16, sizeof(uint64_t) * R_SIZE);
    if (array == NULL) {
	printf("can't allocate memory.\n");
	return 1;
    }
#else /* in this case, gcc doesn't suppport SSE2 */
    printf("malloc used\n");
    array = malloc(sizeof(uint64_t) * R_SIZE);
    if (array == NULL) {
	printf("can't allocate memory.\n");
	return 1;
    }
#endif
    cnt = 0;
    j = 0;
    init_gen_rand(seed);
    fill_array64(array, R_SIZE);
    for (i = 0; i &lt; NUM; i++) {
	x = to_res53(array[j++]);
	y = to_res53(array[j++]);
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    free(array);
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample2.c</strong> with SFMTp.c with the period of
      2<sup>2281</sup>, type</p>
    <blockquote>
      <pre>gcc -o -DMEXP=2281 sample2 SFMTp.c sample2.c</pre>
    </blockquote>
    <p>If your CPU supports SSE2 and you want to use optimized SFMTp for
      SSE2, type</p>
    <blockquote>
      <pre>gcc -msse2 -DMEXP=2281 -o sample2 SFMTp-sse2.c sample2.c</pre>
    </blockquote>
    <p>If your CPU supports AltiVec and you want to use optimized SFMT
      for AltiVec, type</p>
    <blockquote>
      <pre>gcc -faltivec -DMEXP=2281 -o sample2 SFMTp-alti32.c sample2.c</pre>
    </blockquote>
    <p>or type</p>
    <blockquote>
      <pre>gcc -faltivec -DMEXP=2281 -o sample2 SFMTp-alti64.c sample2.c</pre>
    </blockquote>
    <p>The difference between SFMTp-alti32.c and SFMTp-alti64.c is:
      SFMTp-alti32.c support 32-bit and 64-bit output, but 64-bit output
      is slower, on the other hand, SFMTp-alti64.c support 64-bit output
      only, but it's faster than SFMTp-alti32.c
    </p>
    <h4>2-3. Use sequential call and inline functions.</h4>
    <p>
      Here is <strong>sample3.c</strong> which modifies sample1.c.
      This is very similar to sample1.c. The difference is only one line.
      It include <strong>"sfmt19937.c"</strong> instead of <strong>"sfmt19937.h"
      </strong>.
    </p>
    <blockquote>
      <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "sfmt19937.c"

int main(int argc, char* argv[]) {
    int i, cnt, seed;
    double x, y, pi;
    const int NUM = 10000;

    if (argc &gt;= 2) {
	seed = strtol(argv[1], NULL, 10);
    } else {
	seed = 12345;
    }
    cnt = 0;
    init_gen_rand(seed);
    for (i = 0; i &lt; NUM; i++) {
	x = genrand_res53();
	y = genrand_res53();
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample3.c</strong>, type</p>
    <blockquote>
      <pre>gcc -o sample3 sample3.c</pre>
    </blockquote>
    <p>If your CPU supports SSE2 and you want to use optimized SFMT for
      SSE2, change "sfmt19937.c" in sample3.c to "sfmt19937-sse2.c"
      and type</p>
    <blockquote>
      <pre>gcc -msse2 -o sample3 sample3.c</pre>
    </blockquote>
    <p>If your CPU supports AltiVec and you want to use optimized SFMT
      for AltiVec, change "sfmt19937.c" in sample3.c to
      "sfmt19937-alti32.c" or "sfmt19937-alti64.c" and type</p>
    <blockquote>
      <pre>gcc -faltivec -o sample3 sample3.c</pre>
    </blockquote>
    <h4>2-4. Initialize SFMT using init_by_array function.</h4>
    <p>
      Here is <strong>sample4.c</strong> which modifies sample1.c.
      The 32-bit integer seed can only make 2<sup>32</sup> kinds of
      initial state, to avoid this problem, SFMT
      provides <strong>init_by_array</strong> function.  This sample
      uses init_by_array function which initialize the internal state
      array with an array of 32-bit. The size of an array can be
      larger than the internal state array and all elements of the
      array are used for initialization, but too large array is
      wasteful.
    </p>
    <blockquote>
      <pre>
#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include "sfmt19937.h"

int main(int argc, char* argv[]) {
    int i, cnt, seed_cnt;
    double x, y, pi;
    const int NUM = 10000;
    uint32_t seeds[100];

    if (argc &gt;= 2) {
	seed_cnt = 0;
	for (i = 0; (i &lt; 100) &amp;&amp; (i &lt; strlen(argv[1])); i++) {
	    seeds[i] = argv[1][i];
	    seed_cnt++;
	}
    } else {
	seeds[0] = 12345;
	seed_cnt = 1;
    }
    cnt = 0;
    init_by_array(seeds, seed_cnt);
    for (i = 0; i &lt; NUM; i++) {
	x = genrand_res53();
	y = genrand_res53();
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample4.c</strong>, type</p>
    <blockquote>
      <pre>gcc -o sample4 sfmt19937.c sample4.c</pre>
    </blockquote>
    <p>Now, seed can be a string. Like this:</p>
    <blockquote>
      <pre>./sample4 your-full-name</pre>
    </blockquote>
  </body>
</html>
